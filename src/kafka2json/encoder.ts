import { isNullOrUndefined } from "util"
import { Primitive, Schema } from "."

function encodeString(str: string) {
	const bufferString = Buffer.from(str, "utf8")
	const bufferLength = Buffer.alloc(2)
	bufferLength.writeInt16BE(bufferString.byteLength)
	return Buffer.concat([bufferLength, bufferString])
}

function encodeNullableString(str: string | null) {
	if (str === null) {
		const nulledString = Buffer.alloc(2)
		nulledString.writeInt16BE(-1)
		return nulledString
	}
	return encodeString(str)
}

// This was generated by ChatGPT.
function encodeVarInt(value: number) {
	const buffer = Buffer.alloc(10) // VarLong maximum length is 10 bytes
	let index = 0

	while (value >= 0x80) {
		buffer[index++] = (value & 0x7f) | 0x80
		value >>= 7
	}

	buffer[index++] = value & 0x7f
	return buffer.subarray(0, index)
}

/**
 * Welcome the best part of the codebase! The decoder sucks.
 *
 * @param schema
 * @param value
 * @param skipLength
 * @returns
 */
export function encode<T extends { [key: string]: any }>(
	schema: Schema,
	value: T,
	skipLength: boolean = false
) {
	const buffers: Buffer[] = []
	for (const schemaValue of schema) {
		const key = Object.keys(schemaValue)[0]
		const val = value[key]
		switch (schemaValue[key]) {
			case Primitive.Boolean:
				const bufferBoolean = Buffer.alloc(1)
				bufferBoolean.writeInt8(val ? 1 : 0)
				buffers.push(bufferBoolean)
			case Primitive.Int8:
				const bufferInt8 = Buffer.alloc(1)
				bufferInt8.writeInt8(val)
				buffers.push(bufferInt8)
				break
			case Primitive.Int16:
				const bufferInt16 = Buffer.alloc(2)
				bufferInt16.writeInt16BE(val)
				buffers.push(bufferInt16)
				break
			case Primitive.Int32:
				const bufferInt32 = Buffer.alloc(4)
				bufferInt32.writeInt32BE(val)
				buffers.push(bufferInt32)
				break
			case Primitive.Int64:
				const bufferInt64 = Buffer.alloc(8)
				bufferInt64.writeBigInt64BE(val)
				buffers.push(bufferInt64)
				break
			case Primitive.VarInt:
			case Primitive.VarLong:
				buffers.push(encodeVarInt(val))
				break
			case Primitive.String:
				buffers.push(encodeString(val))
				break
			case Primitive.NullableString:
				buffers.push(encodeNullableString(val))
				break
			case Primitive.Bytes:
				const bufferBytesLength = Buffer.alloc(4)
				bufferBytesLength.writeInt32BE(val.byteLength)
				buffers.push(bufferBytesLength)
				buffers.push(val)
				break
			case Primitive.VarIntBytes:
				buffers.push(encodeVarInt(val.byteLength))
				buffers.push(val)
				break
			default:
				if (schemaValue[key] instanceof Array) {
					if (schemaValue[key][0] instanceof Array) {
						const schema = (schemaValue[key] as Schema[])[0] as Schema
						const bufferArrayLength = Buffer.alloc(4)
						bufferArrayLength.writeInt32BE(val.length)
						buffers.push(bufferArrayLength)
						for (const arrayValue of val) {
							buffers.push(encode(schema, arrayValue, true))
						}
					} else {
						const schema = schemaValue[key] as Schema
						buffers.push(encode(schema, val))
					}
					break
				}
		}
	}
	if (skipLength) {
		return Buffer.concat(buffers)
	} else {
		const byteLength = buffers.reduce(
			(acc, buffer) => acc + buffer.byteLength,
			0
		)
		const bufferByteLength = Buffer.alloc(4)
		bufferByteLength.writeInt32BE(byteLength)
		return Buffer.concat([bufferByteLength, ...buffers])
	}
}
